				----------
				user guide
				----------

user guide

    <If you want to know how to use and customize the provided generators, read on:>

* class GeneratorFactory

    <databene generator> provides a set of predefined generator classes.
    You may use them directly or customize them by configuration or derivation.

    The central access point for all generators is the GeneratorFactory.
    Use this to instantiate the predefined generators, e.g.:

--------------------------------------------------------------------------------
    GeneratorFactory factory = GeneratorFactory.getInstance();
    Generator<Boolean> generator = factory.getBooleanGenerator(0.8, 0.1);
--------------------------------------------------------------------------------

    This will create a generator that creates Boolean values with the following characteristics:

    * 10% of the returned values are <<null>>

    * Of the non-null values, 80% are <<true>>

* interface Generator

    You may now use the generator to create Objects with the desired characteristics:

--------------------------------------------------------------------------------
    generator.validate(); // necessary only if unsure
    while (generator.availabe())
        System.out.println(generator.generate());
    generator.close();
--------------------------------------------------------------------------------

    The method <<available()>> tells if another product is available from the generator, the method <<generate()>>
    creates and returns it. For the boolean generator created by the factory example,
    the number of products is unlimited, so the code snippet will run in an infinite loop.

    The method <<validate()>> may be used to check if a generator's setup is alright.
    If it is not, the <<validate()>> method is expected to throw an InvalidGeneratorSetupException.

    A call to <<reset()>> will reset the generator to the initial state.

    When a generator is not used any more it is required to be closed by the <<close()>> method.


* distribution concept

    There are two special issues which often remain unaddressed in testing:

        * using realistic probability distributions (e.g. of items in a shopping cart)

        * creating unique values (e.g. IDs or unique phone numbers for fraud checking)


    For these purposes, <<databene generator>> provides two interfaces, which extend a common interface,
    <<Distribution>>:

        * WeightFunction

        * Sequence

    See the ScatterplotDemo for examples of both.

** WeightFunction

    This is an easy way determine how often a value will occur in an otherwise random generation.
    All the user needs to do is implement a method <<<double value(double param)>>>:

--------------------------------------------------------------------------------
    private static class XFunction implements WeightFunction {
        public double value(double param) {
            double s = Math.sin(param / 30);
            return s * s;
        }
    }
--------------------------------------------------------------------------------

    The function does not need to be normalized, the only condition is, that all result values are greater or equals 0.

** Sequence

    A Sequence lets the user choose or replace the algorithm by which number values are created.
    This can be used for defining long sequences of unique values or custom random funtions.
    Four Sequences are predefined (See the DistributionDemo):

        [Sequence.RANDOM] A random algorithm of equal probability for each value

        [Sequence.SHUFFLE] A deterministic sequence of characters of 'segment/offset type' like 1,5,9, 2,6,10, 3,...

        [Sequence.CUMULATED] A random algorithm with a bell-shape distribution

        [Sequence.RANDOM_WALK] A random sequence that starts from a value and increments or decrements it randomly

    For providing custom sequences, see the CustomSequenceDemo.

* provided generators

    You may get a quick overview of the provided Generators and its features by thecking the API documentation of
    the GeneratorFactory. The following sub sections list the generators by type

** sample generators

    A sample generator uses a single value or a set of values of which it returns one.
    The values may be weighted equally (default), individually or by a distribution.

    The factory methods for sample generators are:

    [public \<T\> Generator\<T\> getConstantGenerator(T value)] Creates the most trivial generator
    which returns the same value again and again.

    [public \<T\> Generator\<T\> getSampleGenerator(Collection\<T\> values)] Creates a generator
    that chooses from a set of values with equal weights.

    [public \<T\> Generator\<T\> getSampleGenerator(T ... values)] Creates a generator
    that chooses from a set of values with equal weights.

    [public \<T\> Generator\<T\> getSampleGenerator(String url, Converter\<T,String\> converter)] Creates a generator
    that reads cell Strings from a CSV file and converts them into objects by a converter.

    [public \<T\> Generator\<T\> getWeightedSampleGenerator(Collection\<Sample\<T\>\> samples)] Creates a generator
    that chooses from a set of samples, using an individual weight for each sample.

    [public \<T\> Generator\<T\> getWeightedSampleGenerator(Sample\<T\> ... samples)] Creates a generator
    that chooses from a set of samples, using an individual weight for each sample.

** primitive generators

    Generators are provided for generating Booleans, Numbers, Dates, Strings and Characters.
    For number generators, extremely many configuration options are available.
    Lets start with one of my personal favorites, the RegexStringGenerator:

        [public Generator\<String\> getRegexStringGenerator(String pattern, int minLength, int maxLength,
            Locale locale, double nullQuota)] Creates a generator that produces Strings
            which match a regular expression with characters from one locale.
            They are checked for a minimum and maximum length
            and the generator will generate a given quota of <<null>> values (detemined by the <<nullQuota>>).

    [public Generator\<Boolean\> getBooleanGenerator(float trueQuota, double nullQuota)] Creates a generator
        for boolean values, which returns a given quota (nullQuota \[0-1\]) of null values. The non-null values
        have a given quota of true values (trueQuota \[0-1\]).

    [public \<T extends Number\> Generator\<T\> getNumberGenerator(Class\<T\> type, T min, T max, T precision,
            Distribution distribution, double nullQuota)] Creates a generator for numbers of any standard Java Number
            implementation (Byte, Short, Int, Long, float, double, BigInteger, BigDecimal) from a given range
            (min \<= x \<= max) and resolution ( x = min + n*resolution, with n being an integer).
            The numbers are distributed according to a dstribution or a weight function (distribution).
            There may be a quota of null values (nullQuota).

    [public \<T extends Number\> Generator\<T\> getNumberGenerator(
            Class\<T\> type, T min, T max, T precision,
            Distribution distribution, T variation1, T variation2,
            double nullQuota)]
    Creates a generator for numbers like the one above with additional variation parameters.
    These may take influence on the distribution characteristics in a way that depends on the selected distribution.

    [public Generator\<Date\> getDateGenerator(Date min, Date max, long precision,
        Distribution distribution, double nullQuota)] Creates a Date generator that generates
        random dates between min and max. Depending on the precision these may be e.g. days or seconds.

    [public Generator\<Date\> getDateGenerator(String url, String pattern, double nullQuota)]
    Creates a date generator that reads date entries from a CSV file of the given URL and SimpleDateFormat pattern.

    [public Generator\<Character\> getCharacterGenerator(Locale locale, double nullQuota)]
        Creates a generator that produces characters of a locale.

    [public Generator\<Character\> getCharacterGenerator(String pattern, Locale locale, double nullQuota)]
        Creates a Character generator that creates characters of a locale which match a regular expression that
        specifies a character set (e.g. '\w').

    [public Generator\<Character\> getCharacterGenerator(Collection\<Character\> characters, double nullQuota)]
        Creates a character generator that creates values from a set of characters (like the SampleGenerator).

    [public Generator\<Character\> getCharacterGenerator(double nullQuota, Character ... characters)]
        Creates a character generator that creates values from a set of characters (like the SampleGenerator).

* converting generators

    Converting generators take the output of one ore more other generators and convert them,
    e.g. by using a MessageFormat:

    [public \<T,S\> Generator\<T\> getConvertingGenerator(Generator\<S\> source, Converter\<T,S\> converter)]
        Creates a generator that accepts products from a source generator and serves them as output after conversion.

    [public Generator\<String\> getMessageGenerator(String pattern, int minLength, int maxLength,
            Generator ... sources)]
        Creates a generator that generates messages by reading the products of several source generators and
        combining them by a Java MessageFormat. The result will be checked for a minimum and maximum length.
        For the pattern format see the documentation of the java.util.MessageFormat.

* collection generators

    Collection generators assemle the output of one or more other generators to collections or arrays:

    [public \<C extends Collection\<I\>, I\> Generator\<C\> getCollectionGenerator(
            Class\<C\> collectionType, Generator\<I\> source, int minLength, int maxLength,
            Distribution lengthDistribution)]
        Creates a generator that combines several products of a source generator to a collection.
        The collection type may be any Java collection interface (e.g. java.util.List) or collection implementation
        that provides a default constructor (e.g. java.util.TreeSet).
        The collections have a minimum and maximum length and have the given distribution.

    [public \<T\> Generator\<T\[\]\> getArrayGenerator(
            Generator\<T\> source, Class\<T\> type, int minLength, int maxLength, Distribution lengthDistribution)]
        Creates a generator that combines several products of a source generator to an array.
        The type to be specified is the element type to be declared by the array (e.g. String).
        The produced arrays have a minimum and maximum length and have the given distribution.

    [public Generator\<Object\[\]\> getArrayGenerator(Generator\[\] sources)]
        Creates a generator that reads products of an array of generators and combines them to an Object array.

* source generators

    Source generators import data from data sources. As of v0.1, only CSV import is supported,
    either by importing cell-by-cell as String or by importing CSV lines as String arrays.

    [public Generator\<String\> getCSVCellGenerator(String url, Iteration iteration)]
        Creates a generator that iterates through a CSV file of the given URL and returns each cell as a String value.
        Line breaks are ignored.
        The generator may iterate once and finish (Iteration.SINGLE) or repetitively (Iteration.REPETITIVE).

    [public Generator\<String\[\]\> getCSVLineGenerator(String url, Iteration iteration)]
        Creates a generator that imports lines from a CSV file of the given URL and returns them as String arrays.

* general advice

    * Use the GeneratorFactory whenever possible instead of instantiating the provided generators directly.
      This is an early version and the GeneratorFactory interface will be subject to less changes
      than the Generator implementations themselves.

    * When using weight functions, take special care of the precision: (max - min) / precision should be less than 1000.

    * If you need to create a large number of unique values, use a predefine Sequence or design a custom one.
      For non-number types you might get on by converting the sequence's numbers with custom Converter implementations.

