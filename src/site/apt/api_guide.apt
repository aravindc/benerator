				-------------
				benerator api
				-------------

benerator api

 This document describes programmatic access to the benerator framework: 

[images/benerator-interfaces.gif]

 TODO: add IdGenerator, IdGeneratorFactory and Script to the diagram

 For detailed information on implementing customizations check the 
 {{{api_reference.html}api reference}} too.

GeneratorFactory

    <databene generator> provides a set of predefined generator classes.
    You may use them directly or customize them by configuration or derivation.

    The central access point for all generators is the GeneratorFactory.
    Use this to instantiate the predefined generators, e.g.:

--------------------------------------------------------------------------------
    Generator<Boolean> generator = GeneratorFactory.getBooleanGenerator(0.8, 0.1);
--------------------------------------------------------------------------------

    This will create a generator that creates Boolean values with the following characteristics:

    * 10% of the returned values are <<null>>

    * Of the non-null values, 80% are <<true>>
    
    See {{#provided generators}} for a list of Generator factory methods.

Generator

    A Generator is a resource that needs setup, creates objects and has a life cycle.
    You could use a generator the following way:

--------------------------------------------------------------------------------
    generator.validate(); // necessary only if unsure
    while (generator.availabe())
        System.out.println(generator.generate());
    generator.close();
--------------------------------------------------------------------------------

    The method <<available()>> tells if another product is available from the generator, the method <<generate()>>
    creates and returns it. For the boolean generator created by the factory example,
    the number of products is unlimited, so the code snippet will run in an infinite loop.

    The method <<validate()>> may be used to check if a generator's setup is alright.
    If it is not, the <<validate()>> method is expected to throw an InvalidGeneratorSetupException.

    A call to <<reset()>> will reset the generator to the initial state.

    When a generator is not used any more it is required to be closed by the <<close()>> method.

Converter

 A converter serves for converting objects - this might be e.g. be information rendering (Date -> String), 
 formatting (String -> URL) or transformation (XML1 -> XML2).
 
 Converters are the easiest way to create and process custom data types.
 
 The interface is as follows:

--------------------------------------------------------------------------------
 Class<T> getTargetType();
 T convert(S sourceValue) throws ConversionException;
--------------------------------------------------------------------------------

 the method <getTargetType()> is used to determine the result type of the conversion,
 the <convert()> method performs the conversion. Note that the ConversionException is an 
 unchecked exception.
    
*available converters

 with benerator, you get the databene-commons library too. It provides many useful converters, like
 
 [ParseFormatConverter] which uses a java.text.Format implementation for parsing strings as objects
 
 [FormatFormatConverter] which uses a java.text.Format implementation for rendering objects as Strings
 
 [String2DateConverter] which uses a SimpleDateFormat for parsing Strings as Date objects
 
 [Number2StringConverter] which formats numbers as Strings
 
 [ScriptConverter] which converts Strings by a Script (e.g. FreeMarker)
 
 [BidirectionalConverter] which can be applied forward and backward
 
 [ReverseConverter] which reverses the conversion directions of a BidirectionalConverter






Distribution

* distribution concept

    There are two special issues which often remain unaddressed in testing:

        * using realistic probability distributions (e.g. of items in a shopping cart)

        * creating unique values (e.g. IDs or unique phone numbers for fraud checking)


    For these purposes, <<databene generator>> provides two interfaces, which extend a common interface,
    <<Distribution>>:

        * WeightFunction

        * Sequence

    See the ScatterplotDemo for examples of both.

** WeightFunction

    This is an easy way determine how often a value will occur in an otherwise random generation.
    All the user needs to do is implement a method <<<double value(double param)>>>:

--------------------------------------------------------------------------------
    private static class XFunction implements WeightFunction {
        public double value(double param) {
            double s = Math.sin(param / 30);
            return s * s;
        }
    }
--------------------------------------------------------------------------------

    The function does not need to be normalized, the only condition is, that all result values are greater or equals 0.

** Sequence

    A Sequence lets the user choose or replace the algorithm by which number values are created.
    This can be used for defining long sequences of unique values or custom random funtions.
    Four Sequences are predefined (See the DistributionDemo):

        [Sequence.RANDOM] A random algorithm of equal probability for each value

        [Sequence.SHUFFLE] A deterministic sequence of characters of 'segment/offset type' like 1,5,9, 2,6,10, 3,...

        [Sequence.CUMULATED] A random algorithm with a bell-shape distribution

        [Sequence.RANDOM_WALK] A random sequence that starts from a value and increments or decrements it randomly

    For providing custom sequences, see the CustomSequenceDemo.

