				-----------
				file format
				-----------

benerator file format

  The benerator configuration file is XML based. The current DTD version is benerator-0.3.dtd,
  the document root is a <<setup>> element:

--------------------------------------------------------------------------------
  <?xml version="1.0" encoding="iso-8859-1"?>
  <!DOCTYPE setup SYSTEM "http://databene.org/benerator-0.3.dtd">
  <setup>
      <!-- content here -->
  </setup>
--------------------------------------------------------------------------------



properties

 As of release 0.4.0, benerator supports global properties.

 You can define them as
 
--------------------------------------------------------------------------------
	<property name="my_name" value="Volker" />
--------------------------------------------------------------------------------

 or import several of them from a properties file:
  
--------------------------------------------------------------------------------
	<include uri="my.properties" />
--------------------------------------------------------------------------------



javabeans and the context

  You can instantiate JavaBeans by an intuitive syntax like this:

--------------------------------------------------------------------------------
  <bean id="db" class="org.databene.platform.db.adapter.DBSystem">
      <property name="url" value="jdbc:mysql://localhost/benerator"/>
      <property name="driver" value="com.mysql.jdbc.Driver"/>
      <property name="user" value="benerator"/>
      <property name="password" value="benerator"/>
  </bean>
--------------------------------------------------------------------------------

  The <<class>> attribute denotes which JavaBean class to instantiate (by the default constructor).
  The enclosed property tags cause the JavaBean's properties to be set to appropriate values.
  Benerator converts common types automatically. If not, you may define a custom ConverterManager
  setup (see databane-commons).

  Objects are made available by exposing them in a context. The id attribute defines the name
  with which an object can be found, e.g. for a 'source' or 'ref' attribute of another element's
  setup.

  So the example above creates an instance of a DBSystem JavaBean class, setting its properties
  to values for connecting a database. The object is retrievable by the context with the id 'db'.

  Note: The class DBSystem implements the interface 'System' which provides (among other features)
  meta information about the entities (tables) contained in the database.

  You can create references to other objects declared before by a 'ref'-attribute in the bean
  declaration. The following example shows this for a task setup, but this can be applied to beans
  and processors as well.

  Note: You may implement the System interface for connecting to other system types like SAP or
  Siebel systems.

  JavaBeans may refer each other and may have collection or attribute properties as shown in the following example:

--------------------------------------------------------------------------------
      <bean id="csv" class="org.databene.platform.csv.CSVEntityExporter">
          <property name="uri" value="customers.csv"/>
          <property name="properties" value="salutation,first_name,last_name"/>
      </bean>

      <bean id="proxy" class="shop.MyProxy">
          <property name="target" ref="csv"/>
      </bean>

      <bean id="log-csv" class="org.databene.model.processor.ProcessorChain">
          <property name="components">
              <bean class="org.databene.model.processor.LoggingProcessor"/>
              <idref bean="proxy"/>
          </property>
      </bean>
--------------------------------------------------------------------------------

As of benerator 0.4.0, you have a simpler syntax for defining databases

--------------------------------------------------------------------------------
	<database id="db" 
		url="jdbc:mysql://localhost/benerator" 
		driver="com.mysql.jdbc.Driver" 
		schema="benerator"
		user="benerator" password="benerator" batch="true"
	/>
--------------------------------------------------------------------------------



tasks

--------------------------------------------------------------------------------
    <run-task class="org.databene.platform.db.adapter.RunSqlScriptTask">
        <property name="uri" value="shop/create_tables.mysql.sql"/>
        <property name="db" ref="db"/>
    </run-task>
--------------------------------------------------------------------------------

  Besides the general 'bean' elements, other elements may be created by using element name and additional attributes
  as processing information.

  The example above tells to create a JavaBean of class 'RunSqlScriptTask' with a uri 'shop/create_tables.mysql.sql'
  and its property 'db' refering the JavaBean "db" in the context. Finally it is executed.

  You may define custom tasks to suit your needs, e.g. for performing health checks, by implementing the interface
  'org.databene.task.Task'. By its interface a Tasks demarks if it is thread-safe or at least parallelizable.

   The element <<run-task>> also supports the attributes

   * count: the total number of times the Task is executed (defaults to 1)

   * pagesize: the number of invocations to execute 'en bloque' (defaults to 1)

   * threads: the number of threads with which to execute the Task (defaults to 1)

importing entities

  Entities can be imported from 'system's, files or other generators.
  A typical application is to (re)use a DBUnit setup file from your (hopefully existing ;-) unit tests:

--------------------------------------------------------------------------------
    <!-- import basic setup from a DBUnit file -->
    <create-entities source="shop/shop.dbunit.xml">
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

  Each created entity is forwarded to one or more processors, which usually will persist objects in a file or system,
  but might also be used to post-process created entities.
  The specified object needs to implement the Processor or the system interface.
  When specifying a system here, it will be used to store the entities.
  File exporters (for CSV and Flat Files) implement the Processor interface.

custom importers

  New import formats can be supported by implementing the EntityIterable interface with a JavaBean implementation,
  instantiating it as <bean> and refering it by its id with a 'source' attribute, e.g.

--------------------------------------------------------------------------------
      <bean id="products_flat" class="org.databene.platform.flat.FlatFileEntityIterable">
          <property name="uri" value="shop/products.import.flat"/>
          <property name="entity" value="product"/>
          <property name="properties" value="ean_code[13],name[30],category_id[9],price[8r0],manufacturer[30]"/>
      </bean>

      <create-entities name="product" source="products_flat">
          <processor class="org.databene.model.processor.LoggingProcessor"/>
      </create-entities>
--------------------------------------------------------------------------------

chaining generators

 Generators may be chained, composed, or reused in different contexts.
 You can do so by instantiating a generator as JavaBean and referring it
 in properties of other JavaBean-instantiated generators or specifying it
 as 'source' attribute like an importer.
 
--------------------------------------------------------------------------------
    <!-- creates a text generator -->
    <bean id="textGen" class="org.databene.benerator.primitive.regex.RegexStringGenerator">
        <property name="pattern" value="([a-z]{3,8}[ ])*[a-z]{3,8}\."/>
    </bean>

    <!-- wraps the text generator and creates messages -->
    <create-entities name="message" count="10">
        <attribute name="text" source="textGen"
                   converter="org.databene.model.converter.MessageConverter" pattern="Message: ''{0}''"/>
        <processor class="org.databene.model.processor.LoggingProcessor"/>
    </create-entities>
--------------------------------------------------------------------------------


creating random entities

  Entities can be generated without any input files - benerator provides a rich set of Generator implementations.
  When using <create-entities> without a 'source' attribute, the registered systems (e.g. the database are requested
  for metadata). From the metadata, attributes are generated that match the metadata (e.g. database) constraints,
  as column length, referenced entities and more. By default, associations are treated as one-to-one associations.

--------------------------------------------------------------------------------
    <!-- create products of random attribs & category -->
    <create-entities name="db_product" count="1000" pagesize="100">
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

  Entities are generated as long as each attribute generator is available and limited by the number specified in the
  'count' attribute. The 'pagesize' defines the number of creations after which a flush() is applied to all processors
  (for a database system this is mapped to a commit).

nesting entities

 Entities can form composition structures, which are generated best by recursive create-entities structures.
 
 TODO: example

exporting generated data to data files

  You will need to reuse some of the generated data for setting up (load) test clients. You can simply export data by an
  appropriate processor:

--------------------------------------------------------------------------------
    <!-- create products of random attribs & category -->
    <create-entities name="db_product" count="1000" pagesize="100">
        <processor ref="db"/>
        <processor class="org.databene.platform.flat.FlatFileEntityExporter">
            <property name="uri" value="products.flat"/>
            <property name="properties" value="ean_code[13],name[30l],price[10r0]"/>
        </processor>
    </create-entities>
--------------------------------------------------------------------------------

imposing one-field business constraints

  Simple constraints, e.g. formats can be assured by defining an appropriate Generator or regular expression, e.g.

--------------------------------------------------------------------------------
    <!-- create products of random attribs & category -->
    <create-entities name="db_product" count="1000" pagesize="100">
        <attribute name="ean_code" generator="org.databene.domain.product.EANGenerator"/>
        <attribute name="name" pattern="[A-Z][A-Z]{5,12}"/>
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

imposing multi-field-constraints

  For supporting multi-field-constraints, you can provide a Generator (with a <<variable>> element) that creates entities,
  JavaBeans or Maps. This may be e.g. a random generator or an importing generator. On each generation run, an instance
  is generated and made available to the other sub generators. They can use the entity or sub elements by a source path
  attribute:

--------------------------------------------------------------------------------
    <create-entities name="db_customer">
        <variable name="person" generator="org.databene.domain.person.PersonGenerator" region="DE"/>
        <attribute name="salutation" source="person.salutation"/>
        <attribute name="first_name" source="person.givenName"/>
        <attribute name="last_name" source="person.familyName"/>
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

  The source path may be composed of property names, map keys and entity features, separated by a dot.

data types

 The following data types are supported:

*------------------+---------------------+-----------+---------------------+
|<<benerator type>>| <<JDBC type name>>  | <<JDBC>>  | <<Java type>>       |
|                  |                     | <<type>>  |                     |
|                  |                     | <<value>> |                     |
*------------------+---------------------+-----------+---------------------+
| byte             | Types.TINYINT       |        -6 | java.lang.Byte      |
|                  | Types.BIT           |        -7 |                     |
*------------------+---------------------+-----------+---------------------+
| short            | Types.SMALLINT      |                   5 | java.lang.Short     |
*------------------+---------------------+-----------+---------------------+
| int              | Types.INTEGER       |         4 | java.lang.Integer   |
*------------------+---------------------+-----------+---------------------+
| big_integer      | Types.BIGINT        |        -5 | java.math.BigInteger|
*------------------+---------------------+-----------+---------------------+
| float            | Types.FLOAT         |         6 | java.lang.Float     |
*------------------+---------------------+-----------+---------------------+
| double           | Types.DOUBLE        |         8 | java.lang.Double    |
|                  | Types.NUMERIC       |         2 |                     |
|                  | Types.REAL          |         7 |                     |
*------------------+---------------------+-----------+---------------------+
| big_decimal      | Types.DECIMAL       |         3 | java.math.BigDecimal|
*------------------+---------------------+-----------+---------------------+
| boolean          | Types.BOOLEAN       |        16 | java.lang.Boolean   |
*------------------+---------------------+-----------+---------------------+
| char             | Types.CHAR          |         1 | java.lang.Character |
*------------------+---------------------+-----------+---------------------+
| date             | Types.DATE          |        91 | java.util.Date      |
|                  | Types.TIME          |        92 |                     |
*------------------+---------------------+-----------+---------------------+
| timestamp        | Types.TIMESTAMP     |        93 | java.sql.Timestamp  |
*------------------+---------------------+-----------+---------------------+
| string           | Types.VARCHAR       |        12 | java.lang.String    |
|                  | Types.LONGVARCHAR   |        -1 |                     |
|                  | Types.CLOB          |      2005 |                     |
*------------------+---------------------+-----------+---------------------+
| object (TODO)    | Types.JAVA_OBJECT   |      2000 | java.lang.Object    | 
*------------------+---------------------+-----------+---------------------+
| binary           | Types.BINARY        |        -2 | byte[]              |
|                  | Types.VARBINARY     |        -3 |                     |
|                  | Types.VARBINARY     |        -4 |                     |
|                  | Types.BLOB          |      2004 |                     |
*------------------+---------------------+-----------+---------------------+
| (specific)       | Types.OTHER         |      1111 | (specific)          |
*------------------+---------------------+-----------+---------------------+
| n/a              | Types.DATALINK      |        70 | n/a                 |
|                  | Types.NULL          |         0 |                     |
|                  | Types.DISTINCT      |      2001 |                     |
|                  | Types.STRUCT        |      2002 |                     |
|                  | Types.ARRAY         |      2003 |                     |
|                  | Types.REF           |      2006 |                     |
*------------------+---------------------+-----------+---------------------+


querying information from a system

  Arbitrary information may be queried from a system by a 'selector' attribute, which is system-dependent.
  For a database SQL is used:

--------------------------------------------------------------------------------
    <create-entities name="db_order" count="30" pagesize="100">
        <attribute name="id" mode="ignored"/>
        <attribute name="customer_id" source="db" selector="select id from db_customer" cyclic="true"/>
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

  The result set of a selector might be quite large, so different strategies (for wrapping any other generator's output)
  are supported:

  * distribution: Maps to the name of a Sequence or WeightFunction class. For this, the complete result set is loaded
    into ram. A Sequence should not be applied to result sets of more than 100.000 elements, a WeightFunction should be
    restricted to at most 10.000 elements.

  * proxy="skip" or proxy="repeat" for iterating sequentially through the set. 'proxy-param1' and 'proxy-param2' may be
    used to specify minimum and maximum of repetitions or skipped elements. If cyclic="true", the result set will be
    re-iterated from the beginning when it has reached the end.


--------------------------------------------------------------------------------
    <create-entities name="db_order_item" count="100" pagesize="100">
        <attribute name="id" mode="ignored"/>
        <attribute name="number_of_items" min="1" max="27" distribution="cumulated"/>
        <attribute name="order_id" source="db" selector="select id from db_order" cyclic="true"/>
        <attribute name="product_id" source="db" selector="select ean_code from db_product" distribution="random"/>
        <processor ref="db"/>
    </create-entities>
--------------------------------------------------------------------------------

all supported generator attributes

    [name] name of the feature to generate

    [type] type of the feature to generate

    [nullable] tells if the feature may be null

    [mode] controls the processing mode: (normal|ignored|secret)

    [pattern] uses a regular expression for String creation or date format pattern for parsing Dates.

    [generator] uses a Generator instance for data creation

    [values] provides a comma-separated list of values to choose from

    [nullQuota] the quota of null values to create

    [converter] the class name of a Converter to apply to the generated objects

    [region] a region to create data for, e.g. reion="DE"

    [locale] a locale to create data for, e.g. locale="de"

    [unique] wether to assure uniqueness, e.g. unique="true". Since this needs to keep every instance in memory, use is
        restricted to 100.000 elelments. For larger numbers you should use Sequence-based algorithms.

    [source] A system, EntityIterator or file to import data from.

    [selector] A system-dependent selector to query for data.

    [trueQuota] the quota of true values created by a Boolean Generator.

    [min] the minimum Number or Date to generate

    [max] the maximum Number or Date to generate

    [precision] the resolution of Numbers or Dates to generate

    [distribution] the distribution to use for Number or Date generation.
        This may be a Sequence name or a WeightFunction class name.

    [variation1] first setup parameter for the distribution

    [variation2] second setup parameter for the distribution

    [minLength] the minimum length of the Strings that are generated

    [maxLength] the maximum length of the Strings that are generated

    [cyclic] auto-resets the generator after it has gone unavailable

    [proxy] wraps a generator with a proxy (skip|repeat), which skips or repeats products

    [proxy-param1] sets the minimum skip size / repeat count of the proxy

    [proxy-param2] sets the maximum skip size / repeat count of the proxy



scripting

 as of release 0.4.0 benerator supports scripting: By implementing a plugin contract,
 you can introduce your own scripting engine. The default for benerator is FreeMarker.
 
 Scripts are supported in
 
 * benerator setup files
 
 * properties files
 
 * DbUnit XML files
 
 * CSV files
 
 * Flat files
 
 A script is denoted by curly braces, e.g. '{Hi, I am ${my_name}}'. This syntax will use 
 the default script engine for rendering the text as, e.g. 'Hi, I am Volker'.
 
 The default script engine is set by the property <benerator.defaultScript>.
 
 If you need to support different script engines (e.g. while combining files from different 
 sources), you can differ them by prepending the scripting engine id, e.g. 
 '{ftl:Hi, I am ${my_name}}' or '{Vel:Hi, I am ${my_name}}'
 
 Scripts in the benerator setup are evaluated while parsing. If you need to dynamically 
 generate script text at runtime, use a attribute.script field:
 
--------------------------------------------------------------------------------
 <attribute name="total_price" script="{${(product[1] * db_order_item.number_of_items)?c}}" />
--------------------------------------------------------------------------------

 With scripts you can access
 
 * environment variables
 
 * JVM parameters
 
 * any JavaBean globally declared in the benerator setup
 
 * the last generated entity of each type
 
 * variable values



staging

 Combining scripting and property files, you get a staging mechanism, which is demonstarted in the 
 shop demo. Check the file demo/shop/shop.ben.xml in your benerator installation. It uses staging 
 for populating all seven supported databases with the same benerator setup file, moving database
 specific code to small properties files.
 
 When invoking benerator with a -Dstage=development JVM parameter, you can make your import

	<include uri="{demo/shop/shop.${stage}.properties}" />



template support

 You can use DbUnit import files for replicating entity graph structures many times on each generated object.
 Say, for each customer in a tested online shop, a default order structure should be created. You would then
 define the order structure in a DbUnit file
 
--------------------------------------------------------------------------------
 <dataset>
    <db_order_item order_id="{${db_order.id}}" number_of_items="2" product_ean_code="8076800195057" total_price="2.40" />
    <db_order_item order_id="{${db_order.id}}" number_of_items="1" product_ean_code="8006550301040" total_price="8.70" />
 </dataset>
--------------------------------------------------------------------------------

 and then create an order for each customer that imports its sub structure from the DbUnit file:

--------------------------------------------------------------------------------
	<create-entities name="db_order" consumer="db">
		<id name="id" strategy="{${id_strategy}}" source="db" param="{${id_param}}" />
		<attribute name="customer_id" source="db" selector="select id from db_customer" />
		<create-entities name="db_order_item" source="demo/shop/default_order.dbunit.xml" consumer="db">
			<id name="id" strategy="{${id_strategy}}" source="db" param="{${id_param}}" />
		</create-entities>
	</create-entities>
--------------------------------------------------------------------------------

 Of course, you have to care for appropriate ids yourself.

id providers

 With release 0.4.0, benerator introduces an IdProvider concept, where you can define own 
 IdProviders and IdProviderFactories with more customizable life cycle handling than  
 normal generators.
 
 An <id> element is defined as follows: 
 
-----------------------------------------------------------------------------------
 <id name="id" strategy="sequhilo" source="db" param="my_seq_name" />
-----------------------------------------------------------------------------------
 
 The currently available startegies are 
 
 * <seqhilo> retrieves 'hi' from a sequence, multiplying them with 100 and creating 100 intermediate keys internally.
   This is the id strategy of choice for high performance data creation from multiple client instances.
   Only works with databases that support sequences: Oracle, DB2, HSQL, PostgreSQL
 
 * <uuid> Can also be executed by multiple clients in parallel, but is restricted to generating string ids.
 
 * <increment> creates key values starting from a start value, increasing by one on each call. 
   Useful only if one client instance generates all data (but this will be the general case). 
 
 * <sequence> retrieves values from a sequence. Since ith requires a database call for each value, it is rather slow. 
   Only works with databases that support sequences: Oracle, DB2, HSQL, PostgreSQL
 
 * <query> retrieves values from a SQL query. 
 
